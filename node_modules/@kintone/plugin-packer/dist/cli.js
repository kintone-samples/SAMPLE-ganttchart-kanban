"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const os_1 = __importDefault(require("os"));
const chokidar = __importStar(require("chokidar"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const debug_1 = __importDefault(require("debug"));
const plugin_manifest_validator_1 = __importDefault(require("@kintone/plugin-manifest-validator"));
const _1 = __importDefault(require("."));
const console_1 = __importDefault(require("./console"));
const gen_error_msg_1 = require("./gen-error-msg");
const create_contents_zip_1 = require("./create-contents-zip");
const debug = (0, debug_1.default)("cli");
const writeFile = (0, util_1.promisify)(fs_1.default.writeFile);
const cli = (pluginDir, options_) => {
    const options = options_ || {};
    const packerLocal = options.packerMock_ ? options.packerMock_ : _1.default;
    return Promise.resolve()
        .then(() => {
        // 1. check if pluginDir is a directory
        if (!fs_1.default.statSync(pluginDir).isDirectory()) {
            throw new Error(`${pluginDir} should be a directory.`);
        }
        // 2. check pluginDir/manifest.json
        const manifestJsonPath = path_1.default.join(pluginDir, "manifest.json");
        if (!fs_1.default.statSync(manifestJsonPath).isFile()) {
            throw new Error("Manifest file $PLUGIN_DIR/manifest.json not found.");
        }
        // 3. validate manifest.json
        const manifest = loadJson(manifestJsonPath);
        throwIfInvalidManifest(manifest, pluginDir);
        let outputDir = path_1.default.dirname(path_1.default.resolve(pluginDir));
        let outputFile = path_1.default.join(outputDir, "plugin.zip");
        if (options.out) {
            outputFile = options.out;
            outputDir = path_1.default.dirname(path_1.default.resolve(outputFile));
        }
        debug(`outputDir : ${outputDir}`);
        debug(`outputFile : ${outputFile}`);
        // 4. generate new ppk if not specified
        const ppkFile = options.ppk;
        let privateKey;
        if (ppkFile) {
            debug(`loading an existing key: ${ppkFile}`);
            privateKey = fs_1.default.readFileSync(ppkFile, "utf8");
        }
        // 5. package plugin.zip
        return Promise.all([
            (0, mkdirp_1.default)(outputDir),
            (0, create_contents_zip_1.createContentsZip)(pluginDir, manifest).then((contentsZip) => packerLocal(contentsZip, privateKey)),
        ]).then((result) => {
            const output = result[1];
            const ppkFilePath = path_1.default.join(outputDir, `${output.id}.ppk`);
            if (!ppkFile) {
                fs_1.default.writeFileSync(ppkFilePath, output.privateKey, "utf8");
            }
            if (options.watch) {
                // change events are fired before chagned files are flushed on Windows,
                // which generate an invalid plugin zip.
                // in order to fix this, we use awaitWriteFinish option only on Windows.
                const watchOptions = os_1.default.platform() === "win32"
                    ? {
                        awaitWriteFinish: {
                            stabilityThreshold: 1000,
                            pollInterval: 250,
                        },
                    }
                    : {};
                const watcher = chokidar.watch(pluginDir, watchOptions);
                watcher.on("change", () => {
                    cli(pluginDir, Object.assign({}, options, {
                        watch: false,
                        ppk: options.ppk || ppkFilePath,
                    }));
                });
            }
            return outputPlugin(outputFile, output.plugin);
        });
    })
        .then((outputFile) => {
        console_1.default.log("Succeeded:", outputFile);
        return outputFile;
    })
        .catch((error) => {
        console_1.default.error("Failed:", error.message);
        return Promise.reject(error);
    });
};
const throwIfInvalidManifest = (manifest, pluginDir) => {
    var _a;
    const result = (0, plugin_manifest_validator_1.default)(manifest, {
        relativePath: validateRelativePath(pluginDir),
        maxFileSize: validateMaxFileSize(pluginDir),
    });
    debug(result);
    if (!result.valid) {
        const msgs = (0, gen_error_msg_1.generateErrorMessages)((_a = result.errors) !== null && _a !== void 0 ? _a : []);
        console_1.default.error("Invalid manifest.json:");
        msgs.forEach((msg) => {
            console_1.default.error(`- ${msg}`);
        });
        throw new Error("Invalid manifest.json");
    }
};
/**
 * Create and save plugin.zip
 */
const outputPlugin = (outputPath, plugin) => {
    return writeFile(outputPath, plugin).then((arg) => outputPath);
};
/**
 * Load JSON file without caching
 */
const loadJson = (jsonPath) => {
    const content = fs_1.default.readFileSync(jsonPath, "utf8");
    return JSON.parse(content);
};
/**
 * Return validator for `relative-path` format
 */
const validateRelativePath = (pluginDir) => {
    return (str) => {
        try {
            const stat = fs_1.default.statSync(path_1.default.join(pluginDir, str));
            return stat.isFile();
        }
        catch (e) {
            return false;
        }
    };
};
/**
 * Return validator for `maxFileSize` keyword
 */
const validateMaxFileSize = (pluginDir) => {
    return (maxBytes, filePath) => {
        try {
            const stat = fs_1.default.statSync(path_1.default.join(pluginDir, filePath));
            return stat.size <= maxBytes;
        }
        catch (e) {
            return false;
        }
    };
};
module.exports = cli;
//# sourceMappingURL=cli.js.map